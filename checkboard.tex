\documentclass{zjureport}
% =============================================
% Part 1 Edit the info
% =============================================

\dmajor{计算机科学}
\dname{颜乐春}
% 假装封装了一下前面的变量定义部分

\newcommand{\stuid}{15124542}
\newcommand{\newdate}{2017-10-09}
\newcommand{\loc}{704}

\newcommand{\course}{算法设计於分析}
\newcommand{\tutor}{神人}
\newcommand{\grades}{59}
\newcommand{\newtitle}{棋盘覆盖问题}
\newcommand{\exptype}{Null}
\newcommand{\group}{None}

% 下划线的一个定义

  
% =============================================
% Part 1 Main document
% =============================================
\begin{document}
\thispagestyle{empty}

\makeCover
%封装了一下这部分
%还把下划线弄了一下

% =============================================
% Part 2 Main document
% =============================================

\section{问题描述於实验目的}
设$n=2^k (k>0)$。在一个$n×n$个方格组成的棋盘中，恰有1个方格与其他方格不同，称该方格为特殊方格。显然，特殊方格在棋盘中可能出现的位置有4k种，因而有n2种不同的棋盘，下图所示是$k=2，n=4$时$16$种棋盘中的一个。\par
棋盘覆盖问题要求用下图所示的4种不同形状的L型骨牌覆盖给定棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。
\subsection{输入}
测试数据有若干行，每行$3$个整数$k，x，y$，其中$n=2k$是棋盘的规模，$(x，y)$是特殊方格的位置坐标，$(k>1)$。
\subsection{输出}
对输入中的每个正整数k，第一行上先输出“Case Num: n=”，接着输出n的值，其中Num是测试数据的序号，从$1$开始。第$2$到第$n+1$行，输出对于规模为$n=2^k$的棋盘的一个覆盖。在该棋盘覆盖中，同一个骨牌用$3$个相同的数字表示。各骨牌表示的数字从1开始编号。特殊方格用@表示。\par
\subsection{输入样例}
\begin{lstlisting}
1 2 1
2 2 3
\end{lstlisting}

\subsection{输出样列}
\begin{lstlisting}
Case 1: n=2
1 @
1 1
Case 2: n=4
1 1 2 2
1 5 # 2
3 5 5 4
3 3 4 4
\end{lstlisting}

\section{实验环境}
Ubuntu 17.04 + gcc 6.3

\section{实验内容和步骤}


  \subsection{设计思路}
  当$k > 0 $时，将2k* 2k的棋盘分割为4个2（k-1）*2（k-1）子棋盘。特殊方格必位于4个较小棋盘之一中，其余3个子棋盘中无特殊方格。为了将这3个无特殊方格的子棋盘化为特殊棋盘，我们用一个L型骨牌覆盖这3个较小的棋盘的回合处，这3个子棋盘被L型骨牌覆盖的方格就成为该棋盘上的特殊方格，从而将原问题化为4个小规模的棋盘覆盖问题。递归地使用这种分割，直至棋盘化简为1*1棋盘。
 \subsection{算法描述}

\section{实现程序}
	\begin{clause}
		\lstinputlisting[language=C++]{code/cheese.cpp}
	\end{clause}


\end{document}
